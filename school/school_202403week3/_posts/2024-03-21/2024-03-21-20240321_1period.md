---
title: "2024년 03월 21일 1교시 요약"
tag: 202403_school
---

### 기본

```py
import numpy as np
arr = np.arange(16).reshape(4,-1)
arr
```

```
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
```

## 인덱싱

```py
arr[0]
arr[:1,2:]
arr[arr>10]
arr[:2,[False,False,True,True]]
arr[:2, [2,3]]
```

```
array([0, 1, 2, 3])

array([[2, 3]])

array([11, 12, 13, 14, 15])

array([[2, 3],
       [6, 7]])

arr[:2, [2,3]] 
```

### 불리언 인덱싱(Boolean Indexing)

- 사용되는 불리언 배열의 형태와 적용할 배열의 형태가 같아야 한다.
- 대상 배열의 **차원과 일치**해야함
- **[arr>10]** : arr의 원소가 10보다 큰 것으로 배열을 만들어서 가져옴
  - arr>10 의 결과는
    ```
    array([[False, False, False, False],
       [False, False, False, False],
       [False, False, False,  True],
       [ True,  True,  True,  True]])
    ```
- **[:2,[False,False,True,True]]** : 0~1번째 행, 2,3열

### 팬시 인덱싱(Fancy Indexing)

- 대상 배열로부터 가져올 인덱스만 나열
- 배열 속 값이 행,열의 위치를 나타낸다.
- **[:2, [2,3]]** : 컬럼(열)을 묶어서 리스트로 만들어서 사용, 2, 3 열을 가져온다.

```py
arr[[2,3,2,1]]
```

```
array([[ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [ 8,  9, 10, 11],
       [ 4,  5,  6,  7]])
```

- **[[2,3,2,1]]** : 콜론(:)이 없으므로 행을 가져오는 것으로 인식됨
  - 2, 3, 2, 1 행을 가져온다.

```py
arr[[1,2],[2,3]]
```

```
array([ 6, 11])
```

- **[[1,2],[2,3]]** : 1,2 행, 2,3 열
  - 1행의 2번째 열, 2행의 3번째 열을 가져온다.

## 전치행렬

```py
arr.T
arr.transpose()
```

```
array([[ 0,  4,  8, 12],
       [ 1,  5,  9, 13],
       [ 2,  6, 10, 14],
       [ 3,  7, 11, 15]])
```

- **전치행렬** : 행과 열을 바꾼다.

## 내적(dot,inner product)

### 벡터

```py
vec1 = np.arange(0,5)
vec2 = np.arange(0,5)
np.dot(vec1, vec2)
```

```
array([0, 1, 2, 3, 4])

array([0, 1, 2, 3, 4])

30
```

- **백터** : 1차원 구조, 크기와 방향을 가진 물리량
- **벡터끼리의 내적 연산** : 각 원소를 곱한 값들을 더한다.
- (0x0)+(1x1)+(2x2)+(3x3)+(4x4) = 30
- 각 배열의 원소 개수가 일치해야한다.
- 벡터 내적 연산의 경우 방향성을 알 수 있다.

---

### 행렬

```py
a = np.array([[1, 3], [2, 4]])
b = np.array([[1, 6], [3, 0]])
np.dot(a, b)
```

```
array([[10,  6],
       [14, 12]])
```

```py
a = np.arange(16).reshape((4,-1))
b = np.arange(8).reshape((4,-1))
np.dot(a, b)
```

```
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

array([[0, 1],
       [2, 3],
       [4, 5],
       [6, 7]])

array([[ 28,  34],
       [ 76,  98],
       [124, 162],
       [172, 226]])
```

- **행렬** : 2차원 구조
- **행렬끼리의 내적 연산** : 한 배열의 행과 한 배열의 열을 곱한다. 벡터의 내적을 여러번 하는 것과 같다.
- 행과 열의 수가 일치해야한다.
- ((1x1)+(3x3)) = 10
- ((1x6)+(3x0)) = 6
- ((2x1)+(4x6)) = 14
- ((2x6)+(4x0)) = 12
- 공식에서는 **np.matmul** 혹은 **@** 을 사용하는 것을 권장하고 있다.

### 행렬의 곱셈(@)

```py
a = np.array([[1, 3], [2, 4]])
b = np.array([[1, 6], [3, 0]])
a @ b
```

```
array([[10,  6],
       [14, 12]])
```

#### 문제

- 2행 3열의 행렬과 내적할 수 있는 행렬을 생성하고 그 내적갑과 행렬곱셈 값을 산출해보세요.

```py
a = np.arange(6).reshape((2,-1))
b = np.arange(6).reshape((3,-1))
np.dot(a,b)
a@b
```

```
array([[0, 1, 2],
       [3, 4, 5]])

array([[0, 1],
       [2, 3],
       [4, 5]])

array([[10, 13],
       [28, 40]])

array([[10, 13],
       [28, 40]])
```

## 곱셈( * , 내적(dot), 행렬곱(@))

- a * b : 각 원소에 대한 곱셈
- np.dot() : 벡터에 대한 내적, 행렬에 대한 내적
- @(행렬곱) : 2차원 행렬에 대한 행렬곱은 행렬의 내적과 동일함, 3차원부터는 외적 방법이 적용됨